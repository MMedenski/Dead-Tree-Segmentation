# Segmentation Pipeline

#1. Load RGB and NRG images
#2. Generate independent segmentation masks (RGB / NRG)
#3. Fuse masks using morphological operations
#4. Compare predicted masks with ground truth
#5. Compute IoU and confusion matrix
#6. Optimize segmentation thresholds


# Libraries

import numpy as np
import configparser
from skimage import io, color, morphology, filters
import matplotlib.pyplot as plt
import os, glob
import cv2
from sklearn.metrics import confusion_matrix, classification_report

# Loading configuration from config.ini 

def load_config(path="config.ini"):
    parser = configparser.ConfigParser()
    parser.read(path)

    config = {

        "paths_img": parser["paths"]["rgb"],
        "paths_img_nrg": parser["paths"]["nrg"],
        "paths_mask": parser["paths"]["masks"],

        "hue_min": parser.getfloat("thresholds", "hue_min"),
        "hue_max": parser.getfloat("thresholds", "hue_max"),
        "sat_thr": parser.getfloat("thresholds", "sat_thr"),
        "val_thr": parser.getfloat("thresholds", "val_thr"),

        "num_images": parser.getint("general", "num_images"),
        "num_compare": parser.getint("general", "num_compare"),
    }

    return config

config = load_config()

paths_img = sorted(glob.glob(config["paths_img"]))
paths_img_nrg = sorted(glob.glob(config["paths_img_nrg"]))
paths_mask = sorted(glob.glob(config["paths_mask"]))

hue_min = float(config["hue_min"])
hue_max = float(config["hue_max"])
sat_thr = float(config["sat_thr"])
val_thr = float(config["val_thr"])

num_images = int(config["num_images"])
num_compare = int(config["num_compare"])

comparison_results = []

assert len(paths_img) > 0, "No RGB images found in config path"
assert len(paths_img_nrg) > 0, "No NRG images found in config path"
assert len(paths_mask) > 0, "No main masks found in config path"

# Program Functions

def generate_segment_mask_rgb(rgb_image, hue_min, hue_max, sat_thr, val_thr):

    hsv = color.rgb2hsv(rgb_image.astype(np.float32) / 255.0)

    H = hsv[:, :, 0]
    S = hsv[:, :, 1]
    V = hsv[:, :, 2]

    hue_mask = (H > hue_min) & (H < hue_max)
    saturation_mask = S > sat_thr
    value_mask = V > val_thr

    mask_rgb = hue_mask & saturation_mask & value_mask
    return mask_rgb.astype(np.uint8)

def generate_segment_mask_nrg(nrg_image):
    nrg = nrg_image.astype(np.float32)

    nir  = nrg[:,:,0]
    red  = nrg[:,:,1]
    green = nrg[:,:,2]

    nir_norm  = (nir - nir.min()) / (nir.max() - nir.min() + 1e-6)
    red_norm  = (red - red.min()) / (red.max() - red.min() + 1e-6)
    green_norm = (green - green.min()) / (green.max() - green.min() + 1e-6)

    mask = (
        (nir_norm < 0.40) &
        (red_norm > 0.55) &
        (green_norm > 0.55)
    )

    return mask.astype(np.uint8)

def connection_mask(rgb_image, nrg_image, hue_min, hue_max, sat_thr, val_thr):

    mask_rgb = generate_segment_mask_rgb(
        rgb_image, hue_min, hue_max, sat_thr, val_thr
    ).astype(np.uint8)

    mask_nrg = generate_segment_mask_nrg(nrg_image).astype(np.uint8)

    combined = np.zeros_like(mask_rgb, dtype=bool)

    combined[(mask_rgb == 1) & (mask_nrg == 1)] = 1
    combined[(mask_rgb == 1) & (mask_nrg == 0)] = 1
    combined[(mask_rgb == 0) & (mask_nrg == 1)] = 0
    combined[(mask_rgb == 0) & (mask_nrg == 0)] = 0


    combined = morphology.binary_opening(combined, morphology.disk(1))
    combined = morphology.binary_closing(combined, morphology.disk(2))
    combined = morphology.remove_small_objects(combined, min_size=50)
    combined = morphology.remove_small_holes(combined, area_threshold=100)
    combined = mask_rgb & morphology.binary_dilation(mask_nrg, morphology.disk(2))
    combined = morphology.binary_closing(combined, morphology.disk(4))



    return combined.astype(np.uint8)

def combined_masks(img, nrg):
    mask_rgb = generate_segment_mask_rgb(
        img, hue_min, hue_max, sat_thr, val_thr
    ).astype(bool)

    mask_nrg = generate_segment_mask_nrg(nrg).astype(bool)

    combined = mask_rgb | mask_nrg

    return combined.astype(np.uint8)



def iou(mask1, mask2):
    inter = np.logical_and(mask1, mask2)
    all = np.logical_or(mask1, mask2)

    inter_sum = np.sum(inter)
    all_sum = np.sum(all)

    iou_score = inter_sum / all_sum
    return iou_score

def preview_loaded_images():
    if len(paths_img) == 0:
        print("No images found")
        return

    idx = 0

    fig, axes = plt.subplots(1, 3, figsize=(18, 6))

    def draw():
        img = io.imread(paths_img[idx])
        nrg = io.imread(paths_img_nrg[idx])
        mask = cv2.imread(paths_mask[idx], cv2.IMREAD_GRAYSCALE)

        axes[0].imshow(img)
        axes[0].set_title("RGB Image")

        axes[1].imshow(nrg)
        axes[1].set_title("NRG Image")

        axes[2].imshow(mask, cmap="gray")
        axes[2].set_title("Generated Mask")

        for ax in axes:
            ax.axis("off")

        fig.suptitle(
            f"{idx+1}/{len(paths_img)} | {os.path.basename(paths_img[idx])}",
            fontsize=14
        )

        fig.canvas.draw_idle()

    def on_key(event):
        nonlocal idx
        if event.key == "right":
            idx = (idx + 1) % len(paths_img)
            draw()
        elif event.key == "left":
            idx = (idx - 1) % len(paths_img)
            draw()

    fig.canvas.mpl_connect("key_press_event", on_key)
    draw()
    plt.show()


def run_evaluation():
    comparison_results.clear()
    
    for i in range(min(num_compare, len(paths_img))):
        img_path = paths_img[i]
        nrg_path = paths_img_nrg[i]
        main_mask_path = paths_mask[i]

        img = io.imread(img_path)
        nrg = io.imread(nrg_path)
        generated_mask = connection_mask(img, nrg, hue_min, hue_max, sat_thr, val_thr);
        rgb_mask = generate_segment_mask_rgb(img, hue_min, hue_max, sat_thr, val_thr);
        nrg_mask = generate_segment_mask_nrg(nrg);
        combined_mask = combined_masks(img, nrg)

        main_mask = cv2.imread(main_mask_path, cv2.IMREAD_GRAYSCALE);

        iou_score = iou(generated_mask, main_mask);

        comparison_results.append({
            'original_image': img,
            'generated_mask': generated_mask,
            'combined_mask': combined_mask,
            'rgb_mask': rgb_mask,
            'nrg_mask': nrg_mask,
            'main_mask': main_mask,
            'iou_score': iou_score,
            'image_filename': os.path.basename(img_path)
        });


def show_comparison_results():
    if len(comparison_results) == 0:
        print("No comparison results to show")
        return

    idx = 0

    fig, axes = plt.subplots(2, 3, figsize=(16, 10))
    axes = axes.flatten()

    def draw():
        result = comparison_results[idx]

        axes[0].imshow(result['original_image'])
        axes[0].set_title(result['image_filename'])

        axes[1].imshow(result['generated_mask'], cmap='gray')
        axes[1].set_title("Generated Mask")

        axes[2].imshow(result['main_mask'], cmap='gray')
        axes[2].set_title("Main Mask")

        axes[3].imshow(result['rgb_mask'], cmap='gray')
        axes[3].set_title("RGB Mask")

        axes[4].imshow(result['nrg_mask'], cmap='gray')
        axes[4].set_title("NRG Mask")

        axes[5].imshow(result['combined_mask'], cmap='gray')
        axes[5].set_title("Combined RGB + NRG")

        for ax in axes:
            ax.axis("off")

        fig.suptitle(
            f"{idx+1}/{len(comparison_results)} | IoU: {result['iou_score']*100:.1f}%",
            fontsize=14
        )

        fig.canvas.draw_idle()

    def on_key(event):
        nonlocal idx
        if event.key == "right":
            idx = (idx + 1) % len(comparison_results)
            draw()
        elif event.key == "left":
            idx = (idx - 1) % len(comparison_results)
            draw()

    fig.canvas.mpl_connect("key_press_event", on_key)
    draw()
    plt.show()

def result_all_stats():
    iou_scores = [result['iou_score'] for result in comparison_results]
    image_filenames = [os.path.basename(result['image_filename']) for result in comparison_results]

    plt.figure(figsize=(15, 7))
    plt.bar(image_filenames, iou_scores, color='skyblue')
    plt.xlabel('Nazwa pliku obrazu')
    plt.ylabel('Wynik IoU')
    plt.title('Comparison results IoUs for all sets')
    plt.xticks(rotation=45, ha='right')
    plt.ylim(0, 1)
    plt.tight_layout()
    plt.show()

def confusion_matrix_all():
    y_main_all = []
    y_pred_all = []

    for result in comparison_results:
        main_mask = result['main_mask'].astype(bool).flatten()
        pred_mask = result['generated_mask'].astype(bool).flatten()

        y_main_all.extend(main_mask)
        y_pred_all.extend(pred_mask)

    cm = confusion_matrix(y_main_all, y_pred_all)
    print("CONFUSION MATRIX (for all images)")
    print("TN  FP")
    print("FN  TP")
    print(cm)
    return confusion_matrix(y_main_all, y_pred_all)

def plot_confusion_matrix(cm, title="Confusion Matrix – normalized (%)"):

    labels = ["Background", "Dead Tree"]

    cm = cm.astype(np.float32)
    cm_percent = cm / cm.sum(axis=1, keepdims=True) * 100

    fig, ax = plt.subplots(figsize=(6, 5))
    im = ax.imshow(cm_percent, vmin=0, vmax=100)

    ax.set_title(title, fontsize=14, pad=10)
    ax.set_xlabel("Prediction", fontsize=12)
    ax.set_ylabel("Ground Truth", fontsize=12)

    ax.set_xticks([0, 1])
    ax.set_yticks([0, 1])
    ax.set_xticklabels(labels)
    ax.set_yticklabels(labels)

    # Explicit cell labels
    cell_names = [
        ["TN\n(Background → Background)", "FP\n(Background → Dead Tree)"],
        ["FN\n(Dead Tree → Background)", "TP\n(Dead Tree → Dead Tree)"]
    ]

    for i in range(2):
        for j in range(2):
            value = cm_percent[i, j]
            text_color = "white" if value > 50 else "black"

            ax.text(
                j, i,
                f"{cell_names[i][j]}\n{value:.1f}%",
                ha="center",
                va="center",
                color=text_color,
                fontsize=11,
                fontweight="bold"
            )

    cbar = fig.colorbar(im, ax=ax)
    cbar.set_label("Percentage of pixels (%)")

    plt.tight_layout()
    plt.show()



def search_best_thresholds(hue_ranges, sats, vals):
    rgb_images = [io.imread(p) for p in paths_img[:num_compare]]
    main_masks = [cv2.imread(p, cv2.IMREAD_GRAYSCALE).astype(bool)
                  for p in paths_mask[:num_compare]]

    hsv_images = [color.rgb2hsv(img.astype(np.float32) / 255.0) for img in rgb_images]

    best_iou = -1
    best_params = (None, None, None, None)

    hue_iou = []
    sat_iou = []
    val_iou = []

    for (hmin, hmax) in hue_ranges:
        ious = []
        for s in sats:
            for v in vals:
                for hsv, main in zip(hsv_images, main_masks):
                    H, S, V = hsv[:,:,0], hsv[:,:,1], hsv[:,:,2]
                    mask = (H > hmin) & (H < hmax) & (S > s) & (V > v)

                    inter = np.logical_and(mask, main).sum()
                    union = np.logical_or(mask, main).sum()
                    ious.append(inter / union if union != 0 else 0)

        hue_iou.append(np.mean(ious))

    for s in sats:
        ious = []
        for (hmin, hmax) in hue_ranges:
            for v in vals:
                for hsv, main in zip(hsv_images, main_masks):
                    H, S, V = hsv[:,:,0], hsv[:,:,1], hsv[:,:,2]
                    mask = (H > hmin) & (H < hmax) & (S > s) & (V > v)

                    inter = np.logical_and(mask, main).sum()
                    union = np.logical_or(mask, main).sum()
                    ious.append(inter / union if union != 0 else 0)

        sat_iou.append(np.mean(ious))

    for v in vals:
        ious = []
        for (hmin, hmax) in hue_ranges:
            for s in sats:
                for hsv, main in zip(hsv_images, main_masks):
                    H, S, V = hsv[:,:,0], hsv[:,:,1], hsv[:,:,2]
                    mask = (H > hmin) & (H < hmax) & (S > s) & (V > v)

                    inter = np.logical_and(mask, main).sum()
                    union = np.logical_or(mask, main).sum()
                    ious.append(inter / union if union != 0 else 0)

        val_iou.append(np.mean(ious))

    for (hmin, hmax) in hue_ranges:
        for s in sats:
            for v in vals:
                ious = []
                for hsv, main in zip(hsv_images, main_masks):
                    H, S, V = hsv[:,:,0], hsv[:,:,1], hsv[:,:,2]
                    mask = (H > hmin) & (H < hmax) & (S > s) & (V > v)

                    inter = np.logical_and(mask, main).sum()
                    union = np.logical_or(mask, main).sum()
                    ious.append(inter / union if union != 0 else 0)

                mean_iou = np.mean(ious)
                if mean_iou > best_iou:
                    best_iou = mean_iou
                    best_params = (hmin, hmax, s, v)


    plt.figure(figsize=(18,5))

    plt.subplot(1,3,1)
    plt.bar(range(len(hue_ranges)), hue_iou)
    plt.xticks(range(len(hue_ranges)),
               [f"{h[0]:.2f}-{h[1]:.2f}" for h in hue_ranges],
               rotation=45)
    plt.title("IoU vs Hue range")
    plt.ylabel("Mean IoU")

    plt.subplot(1,3,2)
    plt.bar(range(len(sats)), sat_iou)
    plt.xticks(range(len(sats)), [f"{s:.2f}" for s in sats])
    plt.title("IoU vs Saturation")

    plt.subplot(1,3,3)
    plt.bar(range(len(vals)), val_iou)
    plt.xticks(range(len(vals)), [f"{v:.2f}" for v in vals])
    plt.title("IoU vs Value")

    plt.tight_layout()
    plt.show()

    print("Best IoU:", best_iou)
    print("Best params:")
    print("Hue:", best_params[0], "-", best_params[1])
    print("S  :", best_params[2])
    print("V  :", best_params[3])

    return best_params, best_iou

def save_iou_results(filename="iou_results.csv"):
    if len(comparison_results) == 0:
        print("No IoU results to save")
        return

    script_dir = os.path.dirname(os.path.abspath(__file__))
    save_path = os.path.join(script_dir, filename)

    with open(save_path, "w", encoding="utf-8") as f:
        f.write("image_name - iou\n")
        for result in comparison_results:
            f.write(f"{result['image_filename']} - {result['iou_score']*100:.2f}%\n")

    print(f"IoU results saved to: {save_path}")



def main():
    preview_loaded_images()
    run_evaluation()
    show_comparison_results()
    result_all_stats()
    cm = confusion_matrix_all()
    plot_confusion_matrix(cm)
    save_iou_results()


if __name__ == "__main__":
  main()

search_best_thresholds(
    hue_ranges=[(0.7, 0.8), (0.75, 0.85), (0.8, 0.9)],
    sats=[0.15, 0.2],
    vals=[0.5, 0.55]
)
